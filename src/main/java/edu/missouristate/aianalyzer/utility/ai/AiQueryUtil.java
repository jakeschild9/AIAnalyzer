package edu.missouristate.aianalyzer.utility.ai;

import com.google.genai.Client;
import com.google.genai.types.Content;
import com.google.genai.types.GenerateContentResponse;
import com.google.genai.types.Part;
import lombok.RequiredArgsConstructor;
<<<<<<< HEAD
=======
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
>>>>>>> clean-feature-branch
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.concurrent.CompletableFuture;

import static edu.missouristate.aianalyzer.utility.ai.ReadFileUtil.*;

/**
 * Utility service that communicates with the Google Gemini AI model to perform
 * text, file, and image-based analysis. This class provides methods for summarizing
 * file content, handling large file uploads, and generating image classification responses.
 */
<<<<<<< HEAD
=======
@Slf4j
>>>>>>> clean-feature-branch
@Service
@RequiredArgsConstructor
public class AiQueryUtil {

    /** Client instance used for all Gemini model requests. */
    private final Client client;

<<<<<<< HEAD
=======
    private final ReadFileUtil readFileUtil;

    private final edu.missouristate.aianalyzer.service.config.CloudConfigService cloudConfigService;

    private String getBucketName() {
        return cloudConfigService.getBucketName();
    }

>>>>>>> clean-feature-branch
    /**
     * Sends the entire file content directly to Gemini for summarization.
     *
     * This method is used for small files whose contents can safely be read
     * entirely into memory. It returns a single sentence of up to 40 words
     * summarizing the file contents.
     *
     * @param file The complete file contents as a string.
     * @return A summary generated by the Gemini model.
     */
    public String activeResponseFromFile(String file) {
<<<<<<< HEAD
        CompletableFuture<GenerateContentResponse> responseFuture =
                client.async.models.generateContent(
                        "gemini-2.0-flash",
                        "Provide a single, up to 40-word sentence summarizing the main point or summary of the following file content. "
                                + file,
=======
//        CompletableFuture<GenerateContentResponse> responseFuture =
//                client.async.models.generateContent(
//                        "gemini-2.0-flash",
//                        "Provide a single, up to 40-word sentence summarizing the main point or summary of the following file content. "
//                                + file,
//                        null);
        CompletableFuture<GenerateContentResponse> responseFuture =
                client.async.models.generateContent(
                        "gemini-2.0-flash",
                        "Analyze this file for security concerns and provide a response in the exact format: 'Classification%Summary'. " +
                                "For Classification, use ONLY one of these three options: Safe, Suspicious, or Malicious. " +
                                "- Use 'Safe' for normal legitimate files with no security concerns. " +
                                "- Use 'Suspicious' for files that contain potentially concerning patterns like obfuscated code, unusual scripts, password hashes, SQL injection attempts, or license cracks. " +
                                "- Use 'Malicious' for files that are clearly harmful, contain malware signatures, or are designed to exploit systems. " +
                                "For Summary, provide a single sentence (up to 40 words) describing what the file contains and why you classified it that way. " +
                                "Example format: 'Suspicious%This file contains obfuscated JavaScript code and attempts to bypass license validation checks.' " +
                                "File content: " + file,
>>>>>>> clean-feature-branch
                        null);

        return responseFuture
                .thenApply(GenerateContentResponse::text)
                .join();
    }

    /**
     * Sends a URI reference to a large file stored remotely to Gemini for analysis.
     *
     * This method is used when the file is too large to read into memory. The file
     * is referenced by URI and labeled with its interpretation type.
     *
     * @param file A URI path pointing to the uploaded file.
     * @param fileInterpretation The interpretation type (for example, text/plain).
     * @return A summary of the remote file's contents, limited to about 40 words.
     */
    public String activeResponseFromLargeFile(String file, String fileInterpretation) {
<<<<<<< HEAD
        Content content = Content.fromParts(
                Part.fromText("Provide a single, up to 40-word sentence summarizing the main point or summary of the following file content."),
=======
//        Content content = Content.fromParts(
//                Part.fromText("Provide a single, up to 40-word sentence summarizing the main point or summary of the following file content."),
//                Part.fromUri(file, fileInterpretation));
        Content content = Content.fromParts(
                Part.fromText("Analyze this file for security concerns and provide a response in the exact format: 'Classification%Summary'. " +
                        "For Classification, use ONLY one of these three options: Safe, Suspicious, or Malicious. " +
                        "- Use 'Safe' for normal legitimate files with no security concerns. " +
                        "- Use 'Suspicious' for files that contain potentially concerning patterns like obfuscated code, unusual scripts, password hashes, SQL injection attempts, or license cracks. " +
                        "- Use 'Malicious' for files that are clearly harmful, contain malware signatures, or are designed to exploit systems. " +
                        "For Summary, provide a single sentence (up to 40 words) describing what the file contains and why you classified it that way. " +
                        "Example format: 'Suspicious%This file contains obfuscated JavaScript code and attempts to bypass license validation checks.'"),
>>>>>>> clean-feature-branch
                Part.fromUri(file, fileInterpretation));

        CompletableFuture<GenerateContentResponse> responseFuture =
                client.async.models.generateContent(
                        "gemini-2.0-flash",
                        content,
                        null);

        return responseFuture
                .thenApply(GenerateContentResponse::text)
                .join();
    }

    /**
<<<<<<< HEAD
=======
     * Safe wrapper for activeResponseFromLargeFile that catches and handles the "no pages" error.
     *
     * @param gcsUri A URI path pointing to the uploaded file.
     * @param mimeType The file MIME type (for example, text/plain).
     * @return A summary of the file's contents, or an error message if the file is empty.
     */
    private String safeActiveResponseFromLargeFile(String gcsUri, String mimeType) {
        try {
            return activeResponseFromLargeFile(gcsUri, mimeType);
        } catch (Exception e) {
            log.error("Error getting AI response for {}: {}", gcsUri, e.getMessage());

            // Check for the specific "no pages" error
            if (e.getMessage() != null && e.getMessage().contains("no pages")) {
                return "Error: The document appears to be empty or has no readable content. " +
                        "Please ensure the file contains text or is not corrupted.";
            }

            // Handle other errors
            return "Error processing file with AI: " + e.getMessage();
        }
    }

    /**
>>>>>>> clean-feature-branch
     * Analyzes an image and determines whether it contains a single human face,
     * two faces, a group of three or more faces, or no human faces at all.
     *
     * If no human faces are detected, the method returns a description of what was photographed.
     *
     * @param image A URI reference to the uploaded image.
     * @param fileInterpretation The image type (such as image/jpeg).
     * @return One of the following: "single", "two", "group", or a description of what is in the photo.
     * @throws IOException If the image reference cannot be read.
     */
    public String respondWithImageCategory(String image, String fileInterpretation) throws IOException {
        Content content = Content.fromParts(
                Part.fromText("Provide the word single or two based on the amount of human faces in this photo if its a" +
                        "group provide the word description sport, hiking, cooking, event, or gathering. If there are not human faces respond with" +
                        "a word describing the contents of the photo such as landscape, food, or miscellaneous."),
                Part.fromUri(image, fileInterpretation));

        CompletableFuture<GenerateContentResponse> responseFuture =
                client.async.models.generateContent(
                        "gemini-2.0-flash",
                        content,
                        null);

        return responseFuture
                .thenApply(GenerateContentResponse::text)
                .join();
    }

    /**
     * Reads a small file into memory and sends its contents to Gemini for summarization.
     *
     * This method is used only for files whose size does not exceed the configured
     * maximum threshold for in-memory processing.
     *
     * @param filePath The filesystem path to the small file.
     * @param fileType The file type or extension.
     * @return A summary string from the AI, or an error message.
     * @throws IOException If the file cannot be read.
     */
    public String processSmallFileAIResponse(Path filePath, String fileType) throws IOException {
        try {
            String fileContent = readFileAsString(filePath, fileType);
            return activeResponseFromFile(fileContent);
        } catch (IOException e) {
            return "Error processing file: " + e.getMessage();
        }
    }

    /**
     * Processes large files by uploading them to Google Cloud Storage and
     * passing their URI reference to Gemini for remote analysis.
     *
     * This method avoids loading large files into memory and instead relies on
     * Gemini's ability to read the file from cloud storage.
     *
     * @param filePath The path to the large file on disk.
     * @param fileType The detected or provided file type.
     * @return A summary from Gemini or an error message.
     * @throws IOException If the file cannot be uploaded or processed.
     */
    public String processLargeFileAIResponse(Path filePath, String fileType) throws IOException {
        if (!Files.exists(filePath)) {
            return "File does not exist: " + filePath;
        }

        try {
<<<<<<< HEAD
            Path parentDir = filePath.getParent();
            String newFileName = filePath.getFileName().toString().replaceFirst("\\.[^.]+$", ".txt");
            Path newFilePath = parentDir.resolve(newFileName).toAbsolutePath();

            uploadFile(filePath, fileType);

            return activeResponseFromLargeFile(
                    "gs://aianalyser/files" + newFilePath,
=======
            // Get just the filename, not the full path
            String fileName = filePath.getFileName().toString();
            String txtFileName = fileName.replaceFirst("\\.[^.]+$", ".txt");

            log.info("Uploading large file to GCS: {}", fileName);

            // Upload the file to Cloud Storage (this handles the conversion to txt)
            readFileUtil.uploadFile(filePath, fileType);

            // Construct the GCS URI with proper path separator
            String gcsUri = "gs://" + getBucketName() + "/files/" + txtFileName;
            log.info("Requesting AI analysis for GCS object: {}", gcsUri);

            // Use the safe wrapper instead of calling activeResponseFromLargeFile directly
            return safeActiveResponseFromLargeFile(
                    gcsUri,
>>>>>>> clean-feature-branch
                    readDocumentType(fileType)
            );

        } catch (IOException e) {
<<<<<<< HEAD
            return "Error processing file: " + e.getMessage();
        }
    }
}
=======
            log.error("Error processing large file: {}", filePath, e);
            return "Error processing file: " + e.getMessage();
        }
    }
}
>>>>>>> clean-feature-branch
